/*****************************************************************************
Copyright (C) 2017 by c3r1c3 <c3r1c3@nevermindonline.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*****************************************************************************/

/* Standard OBS->GPU uploads. */
uniform float4x4 ViewProj;
uniform texture2d image;

/* Filter variables from OBS. */
uniform int radius;
uniform bool blur_alpha;
uniform float tex_x_offset;
uniform float tex_y_offset;
uniform float4 weight_amount[33];


/*
 * Here we set how the base texture will be sampled/read/interpreted.
 * This value is overwritten by the *gs_samplerstate_t struct passed to this
 * shader, but we still need to initialize/set a default value here.
 */
sampler_state textureSampler {
	Filter   = point;
	AddressU = Repeat;
	AddressV = Repeat;
};

/*
 * Here we create the struct to hold the current position and texture info
 * of the vertex in question.
 */
struct VertData {
	float4 pos  : POSITION;
	float2 uv   : TEXCOORD0;
};

/*
 * Now we transform the vertices to world space (and the
 * textures to go with it). In OBS you'll usually want to
 * use the code below, unless you're trying to create a
 * '3D'-esqe effect.
 */
VertData VSGaussianBlurH(VertData vert_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;
	return vert_out;
}

VertData VSGaussianBlurV(VertData vert_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv = vert_in.uv;

	return vert_out;
}

/*
 * Now we have the function that transforms the texture into
 * the "Gaussian Blur Horizontal" version of itself.
 */
float4 PSGaussianBlurH(VertData vert_in) : TARGET
{
	/*
	 * TODO: Move most of this into the vertex shader...
	 * Could provide up to a 60% boost in performance.
	 * We have to do the texture look-ups in the vertex shader and
	 * transfer those results into the pixel shader.
	 */

        float4 imageBufferWidth = (image.Sample(textureSampler, vert_in.uv)
			* weight_amount[0]);
        float holdAlpha = image.Sample(textureSampler, vert_in.uv).a;        

	/* Now create the Horizontal sample: */
	for (int i = 1; i < radius; i++)
	{
                imageBufferWidth += (image.Sample(textureSampler, (vert_in.uv +
				float2((tex_x_offset * i), 0.0)))
				* weight_amount[i]);
		imageBufferWidth += (image.Sample(textureSampler, (vert_in.uv -
				float2((tex_x_offset * i), 0.0)))
				* weight_amount[i]);
        }

	
        if (!blur_alpha)
        {
                imageBufferWidth.a = holdAlpha;
        }

	/* Return the final result. */
	return imageBufferWidth;
}

/*
 * Lastly we have the function that transforms the texture into
 * the "Gaussian Blur Vertical" version of itself.
 */
float4 PSGaussianBlurV(VertData vert_in) : TARGET
{
	/*
	 * TODO: Move most of this into the vertex shader...
	 * Could provide up to a 60% boost in performance.
	 * We have to do the texture look-ups in the vertex shader and
	 * transfer those results into the pixel shader somehow...
	 */
        float4 imageBufferHeight = (image.Sample(textureSampler, vert_in.uv)
			* weight_amount[0]);
        float holdAlpha = image.Sample(textureSampler, vert_in.uv).a;

	/* Now create the Vertical sample: */
	for (int i = 1; i < radius; i++)
	{
		imageBufferHeight += (image.Sample(textureSampler, (vert_in.uv +
				float2(0.0, (tex_y_offset * i))))
				/*((tex_y_offset * (i + i - 1)) +
				((tex_y_offset * (i + i)))) * 0.5))))*/
				* weight_amount[i]);

		imageBufferHeight += (image.Sample(textureSampler, (vert_in.uv -
				float2(0.0, (tex_y_offset * i))))
				/*((tex_y_offset * (i + i - 1)) +
				((tex_y_offset * (i + i)))) * 0.5))))*/
				* weight_amount[i]);
	}

        if (!blur_alpha)
        {
                imageBufferHeight.a = holdAlpha;
        }

	/* Return the final result. */
	return imageBufferHeight;
}

/* This call actually executes the above functions on the GPU. */
technique Draw
{
	pass p0
	{
		vertex_shader = VSGaussianBlurH(vert_in);
		pixel_shader  = PSGaussianBlurH(vert_in);
	}

	pass p1
	{
		vertex_shader = VSGaussianBlurV(vert_in);
		pixel_shader  = PSGaussianBlurV(vert_in);
	}
}
